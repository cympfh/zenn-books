---
title: 合併型

---

## 合併型とは何か

合併型とは保持するデータとして列挙した型のいずれかの型であることを保証するようなデータ型です.  モダンな言語では代数的データ構造やヴァリアント型と呼ばれるものがあります.  合併型はそれらと少し似ていますが, もう少し低級です.

## 合併型の宣言

合併型はとり得る型を `|` で区切って並べて宣言します.

```rust
type <TYPE> = <TYPE> | <TYPE> | ... | <TYPE> ;
```

この宣言文では左辺の `<TYPE>` を合併型として新たに導入します.  右に並べる型はちょうど一つでも構いませんが, 普通は2つ以上です.

```rust
type IntOnly = Int;
type Number = Nat | Int | Float;
```

## 合併型への型キャスト

合併型の宣言は一般的に次の形をしています.
$$\mathrm{type} ~ T = S_1 \mid S_2 \mid \cdots \mid S_n ;$$

[データの型](types#部分型%2C-型キャストシステム) でも触れましたが, 合併型は部分型の宣言でもあります.  すなわち, 各 $S_i$ 型のデータは自然に $T$ 型でもあると言っています.  cumin は暗黙的に $S_i$ 型データを $T$ 型に変換したりはしません.  あなたが明示的に型キャストする必要があります.  $T$ がそのような型キャストを行う関数として機能します.

```rust
type Number = Nat | Int | Float;
Number(0 as Nat)  // これは Number 型のデータ

[
    Number(0 as Nat),
    Number(-1 as Int),
    Number(3.14),
]  // これは Array<Number>
```

一度 `Number()` に通すとそれはもはやただの `Number` 型データであって, それ以上何もわかりません.  内部データが `Nat` なのか `Int` なのか `Float` なのか, cumin コードの上ではもはや区別をつける方法が無いということです.

## 使用例

なぜ合併型なんてものが必要なのか, 或いは便利なのか見ていきましょう.

### 代数的データ構造の表現

色データを表現することを考えましょう.  よくある方法は, RGB と呼ばれる赤緑青の三値をそれぞれ自然数で表現する方法です.  cumin ではこれを次のように表現でいるでしょう.

```rust
struct RGB {
    red: Nat,
    green: Nat,
    blue: Nat,
}
```

それ以外にも色の表現方法はあります.  CMYK という表現では今度は4つの自然数の組で表現します.

```rust
struct CMYK {
    cyan: Nat,
    magenta: Nat,
    yellow: Nat,
    key: Nat
}
```

実際には RGB と CMYK は等価なデータなので一方だけサポートすれば良いという見方もありますが, 直接 RGB または CMYK を使う人にとっては直接使うものを記述する方が自然でしょう.  そこで RGB または CMYK どちらでも良いというデータを cumin で実現したくなります.

Haskell ならこんなふうに書きます:

```haskell
-- haskell
data Color = RGB (Int, Int, Int) | CMYK (Int, Int, Int, Int)
```

こんな書き方は cumin では出来ないのですが, これは `RGB` の定義と `CMYK` の定義をした上で `Color` はこのどちらかである, という定義をしていると見ることが出来ます.  cumin では各部品の定義は struct または enum に任せて, 「このいずれかである」という宣言を合併型の宣言で行うことにします.

```rust
// struct RGB { ... }
// struct CMYK { ... }
type Color = RGB | CMYK;
```

とすると同じことが出来ます.
次にこれを使う方法を見ていきます.

```rust
RGB(255, 255, 255)  // これは RGB データ
```

```rust
Color(RGB(255, 255, 255))  // これは Color データ
```

後述しますが, cumin では次のような糖衣構文を用意しています. これは上のコードと同じ意味です.

```rust
Color.RGB(255, 255, 255)
```

あたかも「`Color` というクラスに生えてる `RGB` メソッド」のように使う事ができます.

`Color` は立派に一つの型なので全く自由に使うことが出来ます.
例えば次は色がついた矩形を表現する構造体です.

```rust
struct Rect {
    height: Float,
    width: Float,
    color: Color,
}
```

### 型制約を緩める

cumin は今まで型制約のなかった設定ファイルに型を導入しようという試みです.  是非ともこれを活用して構造的で型的に安全な設定ファイルを記述してもらいたいものですが, すでにある現実の設定ファイルはしばしばメチャクチャです.  そしてそれらをそのまま再現させるためにはどこかで型制約を緩める必要があります.

合併型は既存の異なる型を同一視する仕組みです.  これを用いれば何でも表現できます.

[配列](arrays) の最後でも少し紹介しましたが, 例えば文字列と整数を同一視して, 文字列または整数を要素とする配列を作ることが出来ます.

```rust
type Element = String | Int;
[Element("Hello"), Element(0), Element(1), Element("world")]  // Array<Element>
```

必要を見極めて使ってください.

### 型エイリアス

ちょうど一つの型に関する合併型は合併型の意味から考えるとほとんど無意味です.  しかしちょうど一つの値を保持するデータ型だと思うことが出来ます.  例えば次は自然数データを一つ持つ `Age` という年齢を表すデータです.

```rust
type Age = Nat;
```

この型に対して `Age(17)` というデータはもはや `Nat` ではないので,

- ただの `Nat` と区別がつく
    - 勝手な型キャストに巻き込まれない
- 冗長な構造体定義から逃れられる
    - やるとしたら `struct Age { value: Nat }` とか？

といった利点が考えられます.
