---
title: データの型

---

## 原始型

以下は cumin がプリミティブに持つことの出来るデータに対応する型です.

- `Nat` 自然数型
- `Int` 整数型
- `Float` 浮動小数点型
- `String` 文字列型
- `Bool` ブーリアン型

## トップ型

どんなデータにも対応する便宜的な型です.

- `Top`

エイリアスとして `_` と書くこともできます.
あらゆる型はトップ型の部分型です.

## 配列型

配列またはリストと呼ばれるデータです.
配列は同じ型を持つデータをゼロ個以上を持つことが出来ます.
型 `T` を要素とする配列の型は次のように書きます.

- `Array<T>`
    - 要素が `T` 型からなる配列

例えば整数の配列は `Array<Int>` です.  `<>` の中はいくらでも入れ子にでき, 整数の配列の配列は `Array<Array<Int>>` です.  また要素の型を指定しない場合はトップ型のエイリアスである `_` を用いて `Array<_>` と記述できます.

## オプショナル型

`null` などと呼ばれるデータを表すための型です.  ただし `null` そのものを表すデータや型を提供する代わりに, 「`null` になりえる文字列」 のように, `null` をとり得る `T` 型として表します.  Optional 型や Maybe 型などとも呼ばれます.

- `Option<T>`
    - `T` 型または `null` を表す型

## 構造体型

複数のデータを組としてグルーピングしたデータです.
構造体は組み込みでは定義されておらず, ユーザーが必要に応じて定義します.

例えば次は `Int` 2つと `String` 1つからなる構造体です.
構造体及びそれが持つデータには名前が付けられているのが特徴です.

```rust
struct ExampleStruct {
    x: Int,
    y: Int,
    name: String,
}
```

この例では `ExampleStruct` という名前の構造体を定義しています.
同時に `ExampleStruct` という名前の型が新たに定義されました.

例えば

- `ExampleStruct(1, 3, "hello")`

は `ExampleStruct` という型を持つデータです.

## 列挙体型

定めた有限集合の内, ちょうど一つを取るようなデータです.
構造体と同様に, 予め定義されたものはなく, ユーザーが必要に応じて定義していきます.

例えば次は四通りを取る列挙体です.

```rust
enum Suit {
    Club,
    Diamond,
    Spade,
    Heart,
}
```

この例では `Suit` という名前の列挙体が定義され, `Suit` という型が導入されます.
`Suit` 型を持つデータは

- `Suit::Club`
- `Suit::Diamond`
- `Suit::Spade`
- `Suit::Heart`

の4つだけです.

## 合併型

複数の型のいずれかをとり得るという型を宣言することが出来ます.
これは共用型 (union types) などと呼ばれるものによく似ています.

例えば次は `Int` または `String` のいずれかを取る型 `IntOrString` を宣言しています.

```rust
type IntOrString = Int | String;
```

ただし一度 `IntOrString` 型がついたデータはその中身が `Int` なのか `String` なのか区別が付かないことに注意してください.

合併型は型であるとともに型キャストする関数としても機能します.  上の例では `IntOrString` は `Int` データを `IntOrString` データに, `String` データを `IntOrString` データに変換する関数として扱われます.  この関数は型情報を付け替える以外は何もしない, 埋め込み写像です.  逆にこれ以外で暗黙的に型キャストする方法はありません.

## 部分型, 型キャストシステム

cumin の型どうしの間には部分型の関係があります.
ひらたく言えば, あるデータが型 `S` を持つときに, これを 型 `T` に **自然に** 変換する方法があるとき,
$$S \leq T$$
と書いて $S$ は $T$ の部分型であるといいます.

### トップ型

あらゆる型はトップ型 `Top` の部分型です.
$$T \leq \mathrm{Top} ,~ \forall T$$

### 数の型

数の型として `Nat`, `Int`, `Float` があります.
これらには次の部分型を関係を持たせてあります.
$$\mathrm{Nat} \leq \mathrm{Int} \leq \mathrm{Float}$$

例えば自然数の $1$ はこれをそのまま整数の $1$ だと見なすことが出来ますし, それをそのまま小数の $1.0$ だと言うことができます.

#### 暗黙の数の型キャスト

cumin が唯一, 型を暗黙的に（ユーザーが指定することなく）型をキャストする場面が数の型です.
`Float` を要求する場面で `Nat` データを渡すと勝手に `Float` にして扱われます.

例えば配列の要素はすべて同じ型であると言いました.
そこに `Nat` や `Float` がすべて混ざっている場合, これは `Array<Float>` となります.

### 合併型は部分型

合併型の宣言は実は単に部分型とそのキャスト関数の宣言に過ぎません.
一般に合併型の宣言は

```rust
type T = S1 | S2 | ... | Sn;
```

の形をしていますが, これは

$$S_i \leq T$$

であることを宣言しています.  そして $S_i$ から $T$ へ変換する **自然な方法** というのがここでは関数 `T` だというわけです.

## 強制型キャスト

`as` キーワードでは数 `Nat` `Int` `Float` と文字列 `String` の間で強制的な型キャストを行います.
ここでは先に挙げたような自然な型キャストでないキャストを行うことができます.
`Float` から `Int` または `Nat` のキャストは丸め込みで近い整数または自然数に変換します.

```rust
// => 2
2.1 as Int
```

```rust
// => 0
-2.1 as Nat
```

`String` から, または `String` への型変換は, 文字列のパース, またはデータを表現する文字列への変換を表します.

```rust
// => "2.1"
2.1 as String
```

```rust
// => 1
"1" as Int
```

基本的に `as` による強制型キャストは容易に実行エラーを起こし得ることに注意してください.

```rust
// ERROR!!
"a" as Nat
```
