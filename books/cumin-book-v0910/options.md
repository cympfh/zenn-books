---
title: オプションデータ

---

## オプション型とは何か

あるフィールドが, `T` 型を与えられるか, または与えられない, といった状況はよくあります. これを表現するのに, 与えられないことを整数なら `-1`, 文字列なら空文字列といった **特別らしさ** を持つ値で表現する場合がありますが, 出来ることならこれは避けたいでしょう. 特別な意味の `-1` なのか, それとも本当に `-1` だから `-1` なのか区別がつかなくなるからです. `null` というデータはそのための一つの解決策です. 実際 JSON でも `null` というデータが出現します.

`null` はいいとして, ではこれを型安全に表現する方法が何かを考える必要がありますが, その答えを人類は既に持っています. OCaml の `Option`, Haskell の `Maybe` がそれです.  `null` を単独に存在させるのではなく, `T` 型に `null` に相当する一点を付加する, いわば `T+1` 型を生やすやり方です.

cumin ではこの型を `Option<T>` と書きます.  例えば null になりえる文字列は `Option<String>` です.

## オプションデータ

`T` 型のデータとして `x` があるとき, `Option<T>` 型で `x` というデータを表現するには

```rust
Some(x)
```

と書きます. 一方で `null` に相当するデータは

```rust
None
```

と書きます.

この考えに慣れていない読者は, なぜ直接 `x` と書かずにわざわざ `Some(x)` などと書かないといけないのか不思議でしょう. しかし単に `x` と書いていいことにすると, これが `T` 型なのか` Option<T>` 型なのか, はたまた `Option<Option<T>>` 型なのかの区別が付かないためです.  `Some` は `T` から `Option<T>` への自然な埋め込み写像だと思う事ができます.
また一方で `None` というのは結局単に `null` と単独で書いてるのと変わらないように見えるかもしれませんが, cumin はその裏でこれが `Option<String>` なのか `Option<Int>` なのかといった型推論を行ってチェックします.

例えば次のデータを cumin は正しく `Array<Option<String>>` であると推論します.

```rust
[None, None, Some("str")]
```

もちろんこれは `Some("str")` があるおかげです.

### 集合的意味論

:::message info
ここは読み飛ばしてもらって構いません
:::

実際には 128bit の制約があるものの, およそ `Nat` という型は自然数全体の集合 $\mathbb N$ に相当します.
このとき `Option<Nat>` というのは次のように考える事ができます.

$\bot$ という記号を自然数でもなんでもない特別なシンボルだとします.  このとき
$$\{ \bot \} \cup \mathbb N$$ これが `Option<Nat>` です.

`Some` は次のような関数です:
$$\mathrm{Some} \colon \mathbb N \to \{\bot\} \cup \mathbb N$$ $$n \mapsto n$$

そして想像通り `None` というのは次のような定数です.
$$\mathrm{None} = \bot ~~ \colon ~~ \{\bot\} \cup \mathbb N$$

`Some` も `None` も見えていないだけでその右下に型に関する添字があると考えると良いでしょう.
$$\mathrm{Some}_T, \mathrm{None}_T.$$
