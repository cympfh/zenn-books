---
title: 関数

---

## 関数とは何か

cumin の関数は数学的な意味の関数とほとんど同じです.  いくつかの引数を受け取って, その引数の値を変数束縛した環境で, 与えられた式を評価する仕組みです.

## 宣言

```rust
let <NAME> (
    <IDENTIFIER> : <TYPE> ,
    ...
) = <EXPR> ;
```

`()` の中身は仮引数と呼ばれ, 変数名とその型をカンマ区切りで列挙します.
また変数と同様に `let` キーワードで始まっていますが, 関数であることを明示するために `fn` キーワードを使っても良いです.

```rust
let f(x: Int) = x + 1;
fn g(x: Int) = f(x) + f(x);
```

仮引数は構造体のフィールドの宣言と全くです. つまり, 構造体と同様にデフォルト値を自由に与えることが許されます.

```rust
let f(x: Int, z: Int = 1) = x + z;
fn g(x: Int) = f(x) + f(x);
```

## 関数適用

関数を宣言すると, 以降で関数に値を適用することで, その関数の式を評価させ, その結果を得る事ができます. これは文法も効果も構造体への適用と実は全く同じです.


```rust
let f(x: Int, z: Int = 1) = x + z;

let two = f(1); // デフォルト値 z=1 が使われた
let three = f(1, 2); //  z=2 が使われた
let four = f{ z = 2, x = 2 };  // 引数の順序は任意
```

### 構造体も型キャストも関数

構造体 `S` を宣言すると `S` という名前で構造体データを作ることが出来ました.  このとき `S` 自体が, フィールドの値を受け取って構造体データを返す関数なのだと思うことが出来ます.  同様に合併型 `T` を宣言したとき, その部分型から `T` への型キャストをするという操作を `T` 自体で書きましたが, やはりこれも `T` という名前の関数なのだと思うことが出来ます.

### 関数合成の糖衣構文

構造体と合併型なんかを組み合わせると, すぐに2つ以上の関数に続けざまに適用したくなります.

```rust
struct S1 {}
struct S2 {}
type T = S1 | S2;
T(S1())
```

このとき関数合成があれば次が成り立つでしょう:
$$(T \cdot S_1)() = T(S_1())$$

cumin にはこれを表現する糖衣構文が用意してあります.
`T(S1())` は次のように書けます.

```rust
T.S1()
```

ここで `.` が関数合成演算に相当しますが, `.` の左右にスペースを挟む事はできません.
ちょうどメソッドチェーンのようなものと思うこともできます.

関数合成は自由に3つ以上並べることもできます.

```rust
let f(x: Int) = x * 2;
struct Result { value: Int }

Result.f.f.f.f(1)  // {value: 16}
```

## クロージャ, レキシカルスコープ

関数はその外の変数や関数を参照することが出来ます.
ただし見ることが出来る環境は, 関数が宣言される時点の環境です.
次の例を考えてみましょう.

```rust
let z = 2;
let f(x: Int) = { ... } ;
let z = 1;
let g(x: Int) = f(x) + f(x);
```

関数 `f` が宣言された時点での環境では `z=2` のみが宣言されています.
`z=1` や関数 `g` が見れないどころか `f` 自体もまだ見れません.
`f` の宣言中ではまだ関数 `f` は存在しないからです.

```rust
let z = 2;
let f(x: Int) = x + z;
let z = 1;
f(0)
```

この評価値は何になるでしょうか？ そしてその結果はあなたの直感通りでしょうか？

### 変数シャドウィングに対する説明

:::message alert
ここは読み飛ばしてもらって構いません.
:::

cumin では関数が第一級の値ではないものの, 意味論としては大した区別はありません.

```rust
let z = e;
// { z を使う }
```

という変数宣言は次のような関数適用と同じ意味です.

```rust
let f(z: _) = { z を使う };
f(e);
```

つまり変数束縛とは引数の適用であり, また関数式とは変数束縛以降のコード全てのことです.

異なる関数が偶然同じ名前の引数を取っているからといって, 同じものだとは誰も思わないでしょう. 変数束縛の章の最後で説明した **変数シャドウィング** は結局のところ, それです.

```rust
let z = 1;
let z = z + 1;
z
```

というのは

```rust
let f2(z: _) = z;
let f1(z: _) = f2(z + 1);
f1(1)
```

というコードを読みやすいよう書いた糖衣構文に過ぎないのです.
