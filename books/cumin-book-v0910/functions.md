---
title: 関数

---

## 関数とは何か

cumin の関数は数学的な意味の関数とほとんど同じです.  いくつかの引数を受け取って, その引数の値を変数束縛した環境で, 与えられた式を評価する仕組みです.

## 宣言

```rust
let <NAME> (
    <IDENTIFIER> : <TYPE> ,
    ...
) = <EXPR> ;
```

`()` の中身は仮引数と呼ばれ, 変数名とその型をカンマ区切りで列挙します.
また変数と同様に `let` キーワードで始まっていますが, 関数であることを明示するために `fn` キーワードを使っても良いです.

```rust
let f(x: Int) = x + 1;
fn g(x: Int) = f(x) + f(x);
```

仮引数は構造体のフィールドの宣言と全くです. つまり, 構造体と同様にデフォルト値を自由に与えることが許されます.

```rust
let f(x: Int, z: Int = 1) = x + z;
fn g(x: Int) = f(x) + f(x);
```

## 関数適用

関数を宣言すると, 以降で関数に値を適用することで, その関数の式を評価させ, その結果を得る事ができます. これは文法も効果も構造体への適用と実は全く同じです.


```rust
let f(x: Int, z: Int = 1) = x + z;

let two = f(1); // デフォルト値 z=1 が使われた
let three = f(1, 2); //  z=2 が使われた
let four = f{ z = 2, x = 2 };  // 引数の順序は任意
```

## クロージャ, レキシカルスコープ

関数はその外の変数や関数を参照することが出来ます.
ただし見ることが出来る環境は, 関数が宣言される時点の環境です.
次の例を考えてみましょう.

```rust
let z = 2;
let f(x: Int) = { ... } ;
let z = 1;
let g(x: Int) = f(x) + f(x);
```

関数 `f` が宣言された時点での環境では `z=2` のみが宣言されています.
`z=1` や関数 `g` が見れないどころか `f` 自体もまだ見れません.
`f` の宣言中ではまだ関数 `f` は存在しないからです.

```rust
let z = 2;
let f(x: Int) = x + z;
let z = 1;
f(0)
```

この評価値は何になるでしょうか？ そしてその結果はあなたの直感通りでしょうか？

### 変数シャドウィングに対する説明

:::message alert
ここは読み飛ばしてもらって構いません.
:::

cumin では関数が第一級の値ではないものの, 意味論としては大した区別はありません.

```rust
let z = e;
// { z を使う }
```

という変数宣言は次のような関数適用と同じ意味です.

```rust
let f(z: _) = { z を使う };
f(e);
```

つまり変数束縛とは引数の適用であり, また関数式とは変数束縛以降のコード全てのことです.

異なる関数が偶然同じ名前の引数を取っているからといって, 同じものだとは誰も思わないでしょう. 変数束縛の章の最後で説明した **変数シャドウィング** は結局のところ, それです.

```rust
let z = 1;
let z = z + 1;
z
```

というのは

```rust
let f2(z: _) = z;
let f1(z: _) = f2(z + 1);
f1(1)
```

というコードを読みやすいよう書いた糖衣構文に過ぎないのです.
