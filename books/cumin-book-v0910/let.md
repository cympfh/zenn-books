---
title: 変数束縛

---

## 変数束縛とは何か

データに名前を与える事ができます.
「変数にデータを代入する」と言ってしまっても良いです.
ただし cumin の変数は「変数」と言いながら, その中の値を変更することはできません. つまり再代入することができません.

## 変数宣言

```rust
let <IDENTIFIER> = <EXPR> ;
```

```rust
let p = (1 + 2) * 10;
```

`=` より右辺の値を評価して, 得られたデータに `p` という名前を与えます.  この宣言以降では原則として `p` は `Nat` であって `30` というデータです.  `p++` だとか `p /= 2` みたいなことはできないので, `p` に関する計算を一行逃さず追わないと `p` が何か分からないなどということはありません.

## 型アノテーション

変数宣言をするときには型アノテーションをすることが出来ます.

```rust
let <IDENTIFIER> : <TYPE> = <EXPR> ;
```

```rust
let p: Int = (1 + 2) * 10;
```

基本的にそのデータの型は右辺を見れば分かるでしょうが, その式が複雑だったり次に紹介する関数を使うと一見では型が分からないことがあります. さらには上の例のように数値のキャストをさせておきたい場合もあるかもしれません.  「この変数はこの型であるハズだ」というコメントを残す気持ちで書いておけば, cumin の処理系が勝手にチェックしてくれますので, これを使わない手はありません.

## 変数シャドウィング

:::message info
無理に理解する必要はありません.
:::

次のようなコードは正しく動きます.

```rust
let z = "str";
// ここでは z="str"
let z = 1;
// ここでは z=1
let z = z + 1;
// ここでは z=2
```

これを見るとあたかも一つの変数 `z` にいろんなデータ（しかも違う型であっても）を再代入出来るように見えるかもしれません.  しかし実際にはこれは異なる3つの変数を宣言しているに過ぎません.  変数名を変えて区別をつけるなら次のようなものです.

```rust
let z0 = "str";
// ここでは z とは z0 のこと
let z1 = 1;
// ここでは z とは z1 のこと
let z2 = z1 + 1;
// ここでは z とは z2 のこと
```

もちろん紛らわしく思えるなら初めから違う名前の変数をつけるべきです.  書きやすさよりも読みやすさを優先しましょう.
