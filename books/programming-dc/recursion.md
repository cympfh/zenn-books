---
title: 再帰, ループ

---

この章ではプログラミング言語の知識を要求する. それは再帰だ.

## 再帰とループ

普通の近代的なプログラミング言語ではひとかたまりの手続きの処理に名前をつけ, それを関数と呼ぶ.  プログラムはその関数の名前を呼ぶことで関数を呼び出せるわけだが, 関数もまた関数を呼ぶことができる.  そのときに自分自身の名前を呼ぶことで自分自身を繰り返し実行することが出来る.  これを再帰という.

```javascript
function f() {
  ...
  f(); // ここが再帰呼び出し
  ...
}
f();  // 最初は普通の関数呼び出し
```

関数の再帰呼び出しが当然の機能であるのと同様に, ループというのも大抵の言語にとって当たり前に備わっている機能であるだろう.
例えば次は自然数の `0` から `9` までを順に print するという擬似コードだ.

```javascript
var i;
for (i = 0; i < 10; ++i) {
  print(i);
}
```

或いは言語によっては少し違う書き方が出来るかもしれないが, とりあえずループといえばこんなものだろう.

dc には `x` や条件分岐によって dc コードを評価する機能があり, これが関数呼び出しに相当する. そしてその中で自分自身を呼ぶことで再帰呼び出しは出来る. しかしループは無い. そこでループは再帰呼び出しで実現出来ることを覚えておくと良い.

上に書いた `0` から `9` までを print するコードは再帰呼び出しで次のように書ける.

```javascript
function f(i) {
  if (i < 10) {
    print(i);
    f(i + 1);
  }
}
f(0);
```

ループ変数 `i` を引数にする関数に書き換えている.  `for` はループ変数の初期化, 反復条件, 更新式の3つを持つが, これがそれぞれ, 最初の関数呼び出しの引数, 条件式, 再帰呼び出しの引数に置き換えられてることに注意すれば読めると思う.

## dc の再帰呼び出し

レジスタ `x` を関数として用いた再帰を書くことを考えよう.  `x` には「反復処理したいなにか」と「`x` 自身を呼ぶ」という2つの処理を記述した dc コードを文字列として store しておけばよい.

![](https://i.imgur.com/FChZdib.jpg)

### yes

反復処理したいなにかとして, "yes" という文字列を print させることにする.  そして最後に, 無条件にレジスタ `x` を呼ぶことにする.  無条件に呼ぶにはレジスタの中身を load してこれを一文字コマンド `x` で実行すればよい.

```bash
# x に入れる文字列
[
 [yes]p  # print "yes"
 lx      # load x
 x       # exec
]
# という文字列をレジスタ x に store
sx

lx  # 改めて x を読み込んで
x   # 実行
```

```bash
# 上のコードのコメントや改行を取り除いて書き直すと
[[yes]plxx]sxlxx
```

これは無条件に `x` 自身を実行するので無限ループを引き起こす.  つまり止まらないプログラムなので実行には注意してほしい.  Bash を使って安全に実行するには次のようにするとよい.

```bash
(bash) $ timeout 1 dc -e '[[yes]plxx]sxlxx'
```

頭の `timeout 1` は続くコマンドを制限時間1秒の間で実行してくれる. 一秒経過してもコマンドが終わらない場合は自動的に打ち切ってくれる.  続く `dc -e` は dc コードを直接一つの文字列として受け取って, 実行するコマンドだ.

### フィボナッチ数

ここからは少し実践的なコードを書いていこう. フィボナッチ数なんてどうだろう. プログラムの要件は次の通り. 初めスタックには $1$ 以上の整数 $n$ という数値データだけが積まれてるとする. この状態から実行すると, $n$ 番目のフィボナッチ数 $F_n$ を表示して停止する. ここで, $F_0 = 0, F_1 = 1, F_2 = 1, F_3 = 2,\ldots,F_m=F_{m-1}+F_{m-2}$ とする. 問題を少しだけ簡単にするために最初の $n$ は $0$ ではないということにした ($n \geq 1$).

さてフィボナッチ数を計算する素直な方法は次の通りだ.  スタックマシンの様子で図示した.

![](https://i.imgur.com/qrJMBqF.jpg)

つまり, フィボナッチ数を $F_0, F_1$ からスタートして, 漸化式 $F_m=F_{m-1}+F_{m-2}$ の通りに小さいものから順に計算する方法だ.  この漸化式によれば $F_m$ を決定するにはその直前2つが分かっていればいいので, 常に直前2つをスタックの上に持っておく.  つまり, 初めは $F_0, F_1$ が下から順に積まれており, ある「更新」操作で $F_1, F_2$ という状態にする.  更新操作を一回すると添字が $1$ だけ増えるので, ちょうど $n$ 回行った直後では $F_n,F_{n+1}$ がスタックに積まれている. ここで `rp` すれば $F_n$ が print されるという算段である.

更新はどう書けるか.
スタックの様子が $a,b$ のときに $b,a+b$ となればよい. 更新後, $b$ は二回登場してるので `d` で複製するとよい. スタックの順序を上手く $b,b,a$ とか $b,a,b$ とできていればそこで `+` することで $b,a+b$ に出来たことになる.

```bash
# コメントにスタックの様子を書く
# スタックで下にあるものから順に書く

# a, b
d
# a, b, b
3R
# b, b, a
+
# b, a+b
```

出来た. `d3R+` がここで欲しかったちょうど一回の「更新」操作になる.

これを $n-1$ 回反復実行するコードにする必要がある.
最初スタックには $n$ だけが積まれているので, これをレジスタ `n` に入れてこれをカウンタ（ループ変数）として使う.

先に擬似コードで示すとこうだ:

```javascript
store(n);

function x() {
  `d3r+`;  // 更新

  n = load(n);  // カウンタ
  n--;
  store(n);
  if (0 < n) {
    x();  // 再帰
  }
}

x();
swap();  // `r`
print(); // `p`
```

そしてこれを dc に翻訳すると...

```bash
5  # 最初の n
sn # をレジスタ n に退避して管理

# 関数 x の定義
[
  d3R+  # 更新操作

  ln    # カウンタ n を読んで
  1-    # 1 引いて
  d sn  # 複製して一個はレジスタ n に保存
        # s はスタックから一つ消費するので, 次に使うために複製が必要

  0<x   # n が 0 より大ならレジスタ x を実行. レジスタ x にはこれ自身が入る（2行下）
        # 比較もまた 0 と n をスタックから消費する
]
sx  # 以上のコマンドを x として保存
0 1  # F0, F1 のセット
lx  # x を読んで
x   # 実行

# この時点でスタックの上から二つ目に欲しい答えがある
r  # 1つ目と二つ目を交換
p  # 1つ目を print
```

store するとデータが消費されてしまうので, 後でまだ使うなら先に複製 `d` しておくなどしていることに注意してほしい.

「ちょうど一つの数値が標準入力から読まれる」という条件下では一行目で $n$ を渡してる部分は `?` コマンドに置き換えるのがよいだろう. そのような変更を加えてきれいに書き直すと

```bash
? sn
[d3R+ln1-dsn0<x] sx
0 1
lxx
rp
```

このようになる. 大変短いコードで記述できるのが dc の魅力の一つだ.

このコードを `fib.dc` という名前でファイルに保存する. そして Bash からは次のようにして実行できる.

```bash
(bash) $ dc fib.dc
```

これはまず `?` による入力待ち状態から始まるので, ちょうど一つの数字を入力してあげる.

```bash
(bash) $ dc fib.dc
3  <--- 入力
2  <--- 出力
```

次のように入力を直接コマンドに渡してもよい.

```bash
(bash) $ dc fib.dc <<< 3
2  <--- 出力
```
