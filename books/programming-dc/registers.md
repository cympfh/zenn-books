---
title: レジスタ変数

---

レジスタの話に進もうと思う.

電卓なら `M+` といったボタンがある. 同様にプログラミング言語には変数という機能がある. それらに相当するのがレジスタだ. dc はスタックに値をいくらでも高くデータを積むことが出来るから, それで十分なのだろうか. 仮に十分だとしても, ユーザーには優しくないだろう. 一旦全然別なところにデータを退避させたり, またスタックに戻したり, そういったことをしたくなる. というわけでレジスタが 256 個用意されている. 普通のプログラミング言語ならユーザーが自由に命名した変数を用意してそこに値を入れることが出来るが, dc では個数は 256 個で固定だし, 名前も予めついている. 名前は次のとおりだ.

```
  0 @ P ` p
! 1 A Q a q
" 2 B R b r
# 3 C S c s
$ 4 D T d t
% 5 E U e u
& 6 F V f v
' 7 G W g w
( 8 H X h x
) 9 I Y i y
* : J Z j z
+ ; K [ k {
, < L \ l |
- = M ] m }
. > N ^ n ~
/ ? O _ o DEL
```

この表は `man ascii` から持ってきた.

いわゆる [ASCII文字](https://ja.wikipedia.org/wiki/ASCII) だ. 正確にはその中でも特殊な制御文字は除いている. いや最後にDELとかいうわけわからない文字があるけれど. 表の一番左上は何も書いていない, のではなくて, 「半角スペース」という文字が書かれている. 半角スペースも立派に「レジスタ名」であるのが全くもって, ややこしい. 常識のある皆さんは常識的な文字だけを選んで使うようにしましょう. 極力アルファベットを使っているのがいいだろうし, もっと言えば, 他のコマンドとかぶらない文字を選ぶのが良いと思う. 実際には全てあなたの自由なので, あなたにとって都合がいいものを選べばいい.

まず, 全てのレジスタはちょうど一個のデータを格納するいわゆる「箱」であり, 初期値として初めには $0$ という数値が入っている.  ということにする.  本当のことを言えばもっと出来ることは多いのだが, ここでは単にそういうことにして説明を続ける.

## store, load

レジスタに値を代入する操作を store, レジスタの値を参照する操作を load という.  それぞれ `s` コマンド, `l` コマンドで実行する.  これらは二文字コマンドで, その二文字目にレジスタ名を持ってくる.  それぞれの正確な挙動は次の通り.

- store
    - pop してデータを得る
    - レジスタの値をこれで上書きする
- load
    - レジスタの値を読む
        - レジスタの中身は変化しない!
    - これを push する

```bash
> 1 2 3
> sx
> f
2
1
# トップにあった 3 というデータは今はレジスタ x にある

> lx
> f
3
2
1
# 3 を持ってきた

> lz
> f
0
3
2
1
# いきなりレジスタ z を参照すると初期値 0 がやってくる
```

「データ」と呼んでるのは数値だけでなく, 文字列のことも対象にしている. もちろん文字列をレジスタに入れる事もできる.

```bash
> [HELLO]
> sx
```

## 数値同士の等号/大小比較

2つの数値の等号/不等号/大小の比較を行うとき, dc は条件分岐を行う.  **比較の結果を返す** のではなくて, **比較の結果が真ならコレを行う** という挙動であることにやや癖がある.  真偽値 (Bool) がある代わりに `if ... then... end` という構文だけが用意されているのだ.  そしてこれをレジスタ変数の章で紹介しているのはミスではなくて, 「コレを行う」を指定するのにレジスタ変数を指定することで実現する.  execute `x` がスタックのトップを dc コマンドとして実行するように, 比較演算子は比較が通った場合にレジスタの中身を dc コマンドとして実行する.

| 数式   | dc   | 使い方の例 | 意味                                             |
|:------:|:----:|:-----------|:-------------------------------------------------|
| $=$    | `=`  | `1 1 =x`   | $1=1$ ならば, レジスタ `x` の中身を実行する      |
| $\ne$  | `!=` | `1 1 !=x`  | $1 \ne 1$ ならば, レジスタ `x` の中身を実行する  |
| $<$    | `<`  | `2 1 <x`   | $1<2$ ならば, レジスタ `x` の中身を実行する      |
| $\not<$ ($\geq$) | `!<`  | `2 1 !<x`   | $1 \geq 2$ ならば, レジスタ `x` の中身を実行する      |
| $>$    | `>`  | `2 1 >x`   | $1>2$ ならば, レジスタ `x` の中身を実行する      |
| $\not>$ ($\leq$) | `!<`  | `2 1 !>x`   | $1 \leq 2$ ならば, レジスタ `x` の中身を実行する      |

順序には十分注意.  引き算の場合 `1 2-` と書けば $1-2$ の意味だったが, 大小比較の場合には `1 2<` は $2<1$ の意味になる.  大変ややこしいと思う.  比較演算子はすぐ左とくっついていると覚えるのがいい. つまり `1 2<r` は $1$ に対して `2<r` を作用させている. そして `2<r` は「2より大きいなら `r` を実行」と読む.

`!` は普通に否定の意味だと思って良い.  `=` に対して `!=` があるし, `>` に対してそれを打ち消す `!>` がある.  そして $>$ の否定とは $\leq$ のことである.

そして使い方だが, 演算子のすぐ後ろにレジスタ名を置いて, 比較が通ったときにその中身を実行してもらう.  `if ... then ... end` という形をしているが, `else ...` に相当するものが書けないことに注意せよ.

実際に使って慣れるほかない.

```bash
> [[Yes]p]  # "Yes" というデータを print する, という dc コマンド
> sx        # これをレジスタ x に退避

> 1 2<x     # 1 が 2 より大なら x を実行
            # なにも実行されない

> 1 2>x     # 1 が 2 より小なら x を実行
Yes         # された!
```

「2つの数値を空白区切りで入力する」というとき, 先の章で説明した `?` はちょうど2つの数値データを push してくれる.
そこで, 数値の1つ目が2つ目より大きいとき "Yes" を出力するプログラムは次で書ける.

```bash
[[Yes]p]sx
?<x
```

いくつも注意点があるのだが, 比較演算子はデータを pop して消費してしまう.
したがって else 相当を書こうと, 続けてまた別な比較を行うときに必要なデータが失われているということがある.
適宜 `s` でレジスタに退避しておくとか, `d` で複製しておくことが求められる.
次は, 「2つの数値を空白区切りで入力する」とき, 1つ目が2つ目より大きいなら "Yes" を, そうでないなら "No" を出力するプログラムである.

```bash
[[Yes]p]sy  # "Yes" 表示コマンド
[[No]p]sn   # "No" 表示コマンド

?
sysx        # 1つ目の x 2つ目を y に入れる

lxly<y      # y<x なら "Yes"
lxly!<n     # y >= x なら "No"
```

かなりややこしいと思う.  実はもっと簡単に書ける.

```bash
[Yes]
[No]
[r]sr
?
<r
p
```

これは今まで紹介したコマンドしか使っていないから, 気合を入れてもらえれば解読できるはずだ.  そしてこれを推し進めるともう少し簡単に書ける（特に `[r]sr` が不要になる）.  あとの章で説明するつもりだが, 自信のある方は考えてみてください.
