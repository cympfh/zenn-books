---
title: MiniPython 言語

---

# MiniPython

本章では Python を小さくした, ただし少し改造した言語 MiniPython を作って, これを例にしていきます.
ちなみに Python である理由は特にありません. 強いて言えば擬似コードを書く時に誰にとっても読みやすそうだからです.

## Python の型

先に Python の話をしましょう.  Python ではすべての値は何かしらのオブジェクトインスタンスです.  例えば `3` という値は `int` のインスタンスです.  このことは次のようにして確認できます

```python
>>> isinstance(3, int)
True
```

このことを 「`3` の型は `int` である」と言ってしまいます.

Python 3.5 からは変数に対して「この変数はこの型である」という宣言ができます.  これは変数の宣言だったり, 関数宣言の中だったりの場面で行うことができます.

```python
x: int

def f(x: int) -> str:
    return f"x is {x}"
```

読むだけなら難しくないでしょう.  興味がある方は [ドキュメント](https://docs.python.org/ja/3/library/typing.html) を参照してください.

## MiniPython の型

本物の Python には予め用意された型が多くあります. これは大変なので `bool` 型と `int` 型しかないような小さな言語 MiniPython を考えることにしましょう.

| 組み込み型 |  意味  |
|:----------:|:------:|
| `NoneType` |  None  |
|   `bool`   | 真偽値 |
|    `int`   |  整数  |

**意味** には「プログラマが考えるニュアンス」を書いています.
もっと直截な意味の与え方があります.  「その型をとり得る値すべての集合」を考えることです.  例えば `bool` は True と False という2つだけからなる集合です.  コレ自体が `bool` の意味だということにするのです.  これを **集合的意味** と呼ぶことにします.

| 組み込み型 |             集合的意味             |
|:----------:|:----------------------------------:|
| `NoneType` |         $\{\mathrm{None}\}$        |
|   `bool`   | $\{\mathrm{True},\mathrm{False}\}$ |
|    `int`   |   $\{\ldots,-2,-1,0,1,2,\ldots\}$  |

これからは意味といったら集合的意味を考え, `bool` 型 に対して `bool` 集合とか呼ぶことにします.

さて, 本当にこの2つだけではさすがにつまらないので, タプル型とリスト型というものを導入します.  これらは型に無限のバリエーションを与えます.  というのも, 型から新しい型を作る操作だからです.

- $\tau, \sigma$ が型であるとき, $(\tau, \sigma)$ も型
    - これをタプル型という
- $\tau$ が型であるとき, $[\tau]$ も型
    - これをリスト型という

$\tau$ や $\sigma$ はなにか具体的な型が入る変数です.
例えば, $\tau = \mathrm{int}, \sigma=\mathrm{bool}$ として `(int, bool)` というタプル型が考えられます.
そして $\tau = \mathrm{(int,bool)}$ としてやって `[ (int, bool) ]` はタプルに関するリスト型です.
このようにして, MiniPython には無限の型があることになります.

## 関数

MiniPython には Python 同様の関数があることにします.  型について上記の制約があるので完全に同じというわけにはいきませんが, 定義できるものについては同様の演算が可能であるとしましょう.

MiniPython の関数の引数及び返り値には型が必須です.

```python
def f(x: int) -> bool:
    return x == 1
```

上記の `f` のことを `int` から `bool` への関数といいます.
この関数は引数は必ず `int` であると言っています.  例えば `False` を渡すといったことは Python では可能ですが, MiniPython ではできません. 引数 `x` は `int` である必要があるからです. （Python の `False` は `0` と等しい…などといった恐ろしい事実は無視します.）

引数が複数あるような関数もあるでしょう.

```python
def f(x: int, y: int) -> bool:
    return x * 2 == y
```

複数の引数が `( , )` と形式で書かれてることからわかるように, この引数は **一つの** タプルであることがわかります. つまり `(int, int)` から `bool` への関数です.

しかしもともと Python が型に無頓着であることを差し引いても, 原理的に型がつかないような関数もあります.

```python
def id(x: t) -> t:  # 任意の t
    return x
```

ここで `t` は任意の型です.  上記の関数 `id` はどんな型の値でも正しく動きます.  このようなものは暗に型のパラメータ `t` が省略されているものとみなします.  例えば `int` から `int` への `id<int>`, `(int, bool)` から `(int, bool)` への `id<(int, bool)>` といったものがすべて `id` という名前で使えるというものです.  `id<int>` と `int<(int, bool)>` は別物であることに注意してください.

## MiniPython の圏

MiniPython の圏 $\mathcal{M}$ を定義します. そもそも圏が何であるかは必要がないのであまり触れません.

まず $\mathcal{M}$ は MiniPython の型すべてを集めてきた集合です.
$$\mathcal M = \{ \tau \mid \tau \text{ は MiniPython の型} \}$$
この各要素のことを圏の対象といいます.  ここでは型を対象にしています.

$\mathcal M$ は集合ですが, 同じ記号をそのまま使って次のようなものも考えます.
$\sigma, \tau \in \mathcal M$ について,
$$\mathcal M(\sigma, \tau) = \{ f \mid f \text{ は $\sigma$ から $\tau$ への関数 } \}$$
一般に $\mathcal M(\sigma, \tau)$ の要素のことを, $\sigma$ から $\tau$ への射といいます. ここでは関数を射としています.

このように対象があって, 対象から対象への射が定まっているとき, これを圏といいます. また, 以上で定めた $\mathcal M$ を MiniPython の圏とします.

一般に $\mathcal M(\sigma, \tau)$ がどんなものかは何もわかりませんが, $\mathcal M(\sigma,\sigma)$ については必ず言えることが一つあります.
$$\mathrm{id} \in \mathcal M(\sigma,\sigma)$$
だということです. ここで `id` は先述した関数です.

```python
def id(x: σ) -> σ:
    return x
```

$\sigma \ne \tau$ のとき, $\mathrm{id} \in \mathcal M(\sigma,\sigma)$ と $\mathrm{id} \in \mathcal M(\tau,\tau)$ はたまたま同じ名前であるだけで異なる関数です.  しかしながらある種, 同じようなものに見えます. これはどのように整理すればよいでしょうか.


